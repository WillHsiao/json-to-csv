<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Italian Brainrot TD</title>
    <style>
        body {
            background-color: #2b2b2b;
            color: white;
            font-family: 'Comic Sans MS', 'Chalkboard SE', sans-serif;
            text-align: center;
            margin: 0;
            overflow: hidden;
            touch-action: none;
        }
        h1 { margin: 5px; font-size: 1.5rem; text-shadow: 2px 2px #ff0000; }
        
        #gameContainer {
            position: relative;
            display: inline-block;
            border: 4px solid #00AA00; /* Italian Flag Green */
            box-shadow: 0 0 20px rgba(255, 0, 0, 0.5);
        }

        canvas { background: #444; display: block; }

        /* UI Overlay */
        #ui-layer {
            margin-top: 10px;
            display: flex;
            justify-content: center;
            gap: 10px;
            flex-wrap: wrap;
        }

        .stat-box {
            background: #222;
            padding: 5px 15px;
            border-radius: 8px;
            border: 2px solid white;
            font-weight: bold;
        }

        #aura-display { color: cyan; border-color: cyan; }
        #lives-display { color: red; border-color: red; }
        #wave-display { color: yellow; border-color: yellow; }

        /* Tower Selection Buttons */
        .tower-btn {
            background: #333;
            color: white;
            border: 2px solid #555;
            padding: 10px;
            border-radius: 8px;
            cursor: pointer;
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 80px;
            transition: transform 0.1s;
        }
        .tower-btn:active { transform: scale(0.95); }
        .tower-btn.selected { border-color: lime; background: #004400; }
        .emoji { font-size: 1.5rem; }
        .cost { font-size: 0.8rem; color: #aaa; }

        #notif {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%);
            font-size: 2rem;
            font-weight: bold;
            text-shadow: 2px 2px black;
            pointer-events: none;
            display: none;
            z-index: 10;
        }
    </style>
</head>
<body>

    <h1>üáÆüáπ Italian Brainrot TD ü§å</h1>
    
    <div id="ui-layer">
        <div id="aura-display" class="stat-box">Aura: 100</div>
        <div id="lives-display" class="stat-box">Sanity: 20</div>
        <div id="wave-display" class="stat-box">Wave: 1</div>
    </div>

    <div id="gameContainer">
        <canvas id="gameCanvas"></canvas>
        <div id="notif"></div>
    </div>

    <div id="ui-layer">
        <div class="tower-btn" onclick="selectTower(0)" id="btn0">
            <span class="emoji">üë®‚Äçüç≥</span>
            <span>Chef</span>
            <span class="cost">50 Aura</span>
        </div>
        <div class="tower-btn" onclick="selectTower(1)" id="btn1">
            <span class="emoji">üëµ</span>
            <span>Nonna</span>
            <span class="cost">120 Aura</span>
        </div>
        <div class="tower-btn" onclick="selectTower(2)" id="btn2">
            <span class="emoji">üóø</span>
            <span>Mogger</span>
            <span class="cost">200 Aura</span>
        </div>
    </div>
    
    <p style="font-size: 0.8rem; color: #888;">Tap map to place. Don't let the Pineapple Pizza reach the Pope!</p>

<script>
/** CONFIG **/
const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');
// Responsive canvas
const TILE = 40;
const COLS = 16;
const ROWS = 10;
canvas.width = TILE * COLS;
canvas.height = TILE * ROWS;

// Game State
let aura = 100;
let lives = 20;
let wave = 1;
let frame = 0;
let gameOver = false;
let selectedTowerIdx = -1;

// Lists
const towers = [];
const enemies = [];
const projectiles = [];
const particles = [];

// The Path (Coordinates in Grid Units)
// A simple winding path
const pathPoints = [
    {x:0, y:2}, {x:4, y:2}, {x:4, y:7}, {x:10, y:7}, {x:10, y:2}, {x:14, y:2}, {x:14, y:8}, {x:15, y:8}
];

// Tower Types
const towerTypes = [
    { name: "Sigma Chef",   emoji: "üë®‚Äçüç≥", cost: 50,  range: 3,  cooldown: 30, damage: 10, color: "white", proj: "üçù" },
    { name: "Nonna",        emoji: "üëµ", cost: 120, range: 6,  cooldown: 60, damage: 50, color: "pink",  proj: "ü©¥" }, // La Chancla
    { name: "Mogger",       emoji: "üóø", cost: 200, range: 2.5, cooldown: 45, damage: 0.5, color: "gray",  proj: "ü§´" } // AoE shockwave
];

// Enemy Types (Brainrot themed)
// types: 0=PineapplePizza, 1=KetchupPasta, 2=Skibidi
const enemyTypes = [
    { name: "Pineapple", emoji: "üçç", hp: 30,  speed: 0.05, reward: 5 },
    { name: "Ketchup",   emoji: "ü©∏", hp: 80,  speed: 0.02, reward: 10 },
    { name: "Skibidi",   emoji: "üöΩ", hp: 300, speed: 0.015, reward: 50 } // Boss
];

/** CLASSES **/

class Enemy {
    constructor(typeIdx) {
        const type = enemyTypes[typeIdx];
        this.emoji = type.emoji;
        this.hp = type.hp + (wave * 5); // Scaling difficulty
        this.maxHp = this.hp;
        this.speed = type.speed;
        this.reward = type.reward;
        
        // Pathing logic
        this.pathIdx = 0;
        this.x = pathPoints[0].x;
        this.y = pathPoints[0].y;
        this.frozen = 0; // Slow effect
    }

    update() {
        if (this.frozen > 0) {
            this.frozen--;
        }

        const target = pathPoints[this.pathIdx + 1];
        if (!target) return; // Reached end

        const dx = target.x - this.x;
        const dy = target.y - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);
        
        let moveSpeed = this.speed;
        if (this.frozen > 0) moveSpeed *= 0.5; // Slowed by Mogger

        if (dist < moveSpeed) {
            this.x = target.x;
            this.y = target.y;
            this.pathIdx++;
            if (this.pathIdx >= pathPoints.length - 1) {
                this.reachedEnd();
            }
        } else {
            this.x += (dx / dist) * moveSpeed;
            this.y += (dy / dist) * moveSpeed;
        }
    }

    draw() {
        const sx = this.x * TILE + TILE/2;
        const sy = this.y * TILE + TILE/2;
        
        // Health bar
        const hpPct = this.hp / this.maxHp;
        ctx.fillStyle = 'red';
        ctx.fillRect(sx - 10, sy - 20, 20, 4);
        ctx.fillStyle = '#0f0';
        ctx.fillRect(sx - 10, sy - 20, 20 * hpPct, 4);

        ctx.font = "24px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.emoji, sx, sy);
    }

    reachedEnd() {
        this.hp = 0; // Kill self
        lives--;
        createParticle(this.x, this.y, "‚ùå");
        updateUI();
        if (lives <= 0) endGame();
    }
}

class Tower {
    constructor(c, r, typeIdx) {
        this.c = c;
        this.r = r;
        this.type = towerTypes[typeIdx];
        this.cd = 0; // cooldown
    }

    update() {
        if (this.cd > 0) this.cd--;

        // Find target
        if (this.cd <= 0) {
            // "Mogger" is special (AoE around self)
            if (this.type.name === "Mogger") {
                let hit = false;
                enemies.forEach(e => {
                    const dist = Math.hypot(e.x - this.c, e.y - this.r);
                    if (dist <= this.type.range) {
                        e.hp -= this.type.damage; // Tick damage
                        e.frozen = 20; // Apply slow
                        hit = true;
                    }
                });
                if (hit) {
                     // Draw shockwave effect constantly if hitting
                     ctx.beginPath();
                     ctx.arc(this.c * TILE + TILE/2, this.r * TILE + TILE/2, this.type.range * TILE, 0, Math.PI*2);
                     ctx.strokeStyle = "rgba(255, 255, 0, 0.3)";
                     ctx.stroke();
                }
                return; // Mogger doesn't shoot projectiles
            }

            // Normal Shooters
            let target = null;
            let minDst = Infinity;

            // Target First (furthest along path)
            for (const e of enemies) {
                const dist = Math.hypot(e.x - this.c, e.y - this.r);
                if (dist <= this.type.range) {
                    // Simple logic: pick closest
                    if (dist < minDst) {
                        minDst = dist;
                        target = e;
                    }
                }
            }

            if (target) {
                this.cd = this.type.cooldown;
                projectiles.push(new Projectile(this.c, this.r, target, this.type));
            }
        }
    }

    draw() {
        const x = this.c * TILE;
        const y = this.r * TILE;
        
        // Base
        ctx.fillStyle = '#333';
        ctx.fillRect(x+2, y+2, TILE-4, TILE-4);

        ctx.font = "24px Arial";
        ctx.textAlign = "center";
        ctx.textBaseline = "middle";
        ctx.fillText(this.type.emoji, x + TILE/2, y + TILE/2);
    }
}

class Projectile {
    constructor(startC, startR, target, type) {
        this.x = startC * TILE + TILE/2;
        this.y = startR * TILE + TILE/2;
        this.target = target;
        this.damage = type.damage;
        this.emoji = type.proj;
        this.speed = 8;
        this.active = true;
    }

    update() {
        if (!this.target || this.target.hp <= 0) {
            this.active = false;
            return;
        }
        
        const tx = this.target.x * TILE + TILE/2;
        const ty = this.target.y * TILE + TILE/2;
        
        const dx = tx - this.x;
        const dy = ty - this.y;
        const dist = Math.sqrt(dx*dx + dy*dy);

        if (dist < this.speed) {
            // Hit
            this.target.hp -= this.damage;
            this.active = false;
            if (this.target.hp <= 0) {
                 aura += this.target.reward;
                 createParticle(this.target.x, this.target.y, "üíÄ");
                 updateUI();
            }
        } else {
            this.x += (dx/dist) * this.speed;
            this.y += (dy/dist) * this.speed;
        }
    }

    draw() {
        ctx.font = "16px Arial";
        ctx.fillText(this.emoji, this.x, this.y);
    }
}

function createParticle(gridX, gridY, text) {
    particles.push({
        x: gridX * TILE + TILE/2,
        y: gridY * TILE + TILE/2,
        text: text,
        life: 30
    });
}

/** GAME LOGIC **/

function init() {
    updateUI();
    requestAnimationFrame(gameLoop);
}

function updateUI() {
    document.getElementById('aura-display').innerText = `Rizz: ${aura}`;
    document.getElementById('lives-display').innerText = `Sanity: ${lives}`;
    document.getElementById('wave-display').innerText = `Wave: ${wave}`;
}

function selectTower(idx) {
    selectedTowerIdx = idx;
    // UI feedback
    [0,1,2].forEach(i => {
        document.getElementById(`btn${i}`).classList.remove('selected');
    });
    document.getElementById(`btn${idx}`).classList.add('selected');
}

// Spawning Logic
let spawnTimer = 0;
let enemiesToSpawn = 0;
let spawnType = 0;

function manageWaves() {
    if (enemies.length === 0 && enemiesToSpawn === 0) {
        // Wave Complete, start next
        wave++;
        enemiesToSpawn = 5 + Math.floor(wave * 1.5);
        spawnTimer = 0;
        updateUI();
        // Notify
        showNotif(`WAVE ${wave} INCOMING!`);
    }

    if (enemiesToSpawn > 0) {
        spawnTimer++;
        if (spawnTimer > 60) { // spawn every second roughly
            // Determine type based on wave
            let type = 0;
            if (wave > 2) type = Math.random() > 0.7 ? 1 : 0;
            if (wave % 5 === 0 && enemiesToSpawn === 1) type = 2; // Boss at end of wave 5, 10...
            
            enemies.push(new Enemy(type));
            enemiesToSpawn--;
            spawnTimer = 0;
        }
    }
}

function showNotif(text) {
    const n = document.getElementById('notif');
    n.innerText = text;
    n.style.display = 'block';
    setTimeout(() => { n.style.display = 'none'; }, 2000);
}

function endGame() {
    gameOver = true;
    showNotif("L BOZO + RATIO (GAME OVER)");
    document.getElementById('notif').style.color = "red";
}

function gameLoop() {
    if (gameOver) return;
    
    ctx.clearRect(0,0, canvas.width, canvas.height);

    // Draw Map (Background)
    ctx.fillStyle = "#222";
    ctx.fillRect(0,0,canvas.width, canvas.height);

    // Draw Path
    ctx.strokeStyle = "#444";
    ctx.lineWidth = TILE * 0.8;
    ctx.lineCap = "round";
    ctx.lineJoin = "round";
    ctx.beginPath();
    const p0 = pathPoints[0];
    ctx.moveTo(p0.x * TILE + TILE/2, p0.y * TILE + TILE/2);
    for (let i=1; i<pathPoints.length; i++) {
        const p = pathPoints[i];
        ctx.lineTo(p.x * TILE + TILE/2, p.y * TILE + TILE/2);
    }
    ctx.stroke();

    // End Zone
    const lastP = pathPoints[pathPoints.length-1];
    ctx.font = "30px Arial";
    ctx.fillText("‚õ™", lastP.x * TILE + TILE/2, lastP.y * TILE + TILE/2);


    // Update & Draw Towers
    towers.forEach(t => { t.update(); t.draw(); });

    // Update & Draw Enemies
    for (let i = enemies.length - 1; i >= 0; i--) {
        const e = enemies[i];
        e.update();
        e.draw();
        if (e.hp <= 0) enemies.splice(i, 1);
    }

    // Update & Draw Projectiles
    for (let i = projectiles.length - 1; i >= 0; i--) {
        const p = projectiles[i];
        p.update();
        p.draw();
        if (!p.active) projectiles.splice(i, 1);
    }

    // Particles
    for (let i = particles.length - 1; i >= 0; i--) {
        const p = particles[i];
        ctx.font = "20px Arial";
        ctx.globalAlpha = p.life / 30;
        ctx.fillText(p.text, p.x, p.y - (30 - p.life)); // float up
        p.life--;
        if(p.life <= 0) particles.splice(i, 1);
    }
    ctx.globalAlpha = 1;

    // Draw Grid Overlay (Subtle) for placement
    if (selectedTowerIdx > -1) {
        ctx.strokeStyle = "rgba(255,255,255,0.1)";
        ctx.lineWidth = 1;
        for(let r=0; r<ROWS; r++) {
            for(let c=0; c<COLS; c++) {
                ctx.strokeRect(c*TILE, r*TILE, TILE, TILE);
            }
        }
    }

    manageWaves();

    requestAnimationFrame(gameLoop);
}

/** INPUT **/
canvas.addEventListener('mousedown', handleClick);
canvas.addEventListener('touchstart', e => {
    // prevent scroll
    if(e.target == canvas) e.preventDefault();
    handleClick(e.touches[0]);
});

function handleClick(e) {
    if (gameOver) return;
    if (selectedTowerIdx === -1) return;

    const rect = canvas.getBoundingClientRect();
    const x = e.clientX - rect.left;
    const y = e.clientY - rect.top;
    
    // Scale for canvas resolution vs css size
    const scaleX = canvas.width / rect.width;
    const scaleY = canvas.height / rect.height;

    const c = Math.floor((x * scaleX) / TILE);
    const r = Math.floor((y * scaleY) / TILE);

    // Checks
    if (c < 0 || c >= COLS || r < 0 || r >= ROWS) return;
    
    // 1. Check Cost
    const towerInfo = towerTypes[selectedTowerIdx];
    if (aura < towerInfo.cost) {
        showNotif("NOT ENOUGH RIZZ!");
        return;
    }

    // 2. Check overlap with towers
    const existing = towers.find(t => t.c === c && t.r === r);
    if (existing) return;

    // 3. Check overlap with Path (Simple point collision for line segments)
    if (isOnPath(c, r)) {
        showNotif("CANT BUILD ON THE ROAD");
        return;
    }

    // Place
    aura -= towerInfo.cost;
    towers.push(new Tower(c, r, selectedTowerIdx));
    updateUI();
    
    // Create dust effect
    createParticle(c, r, "üí®");
}

function isOnPath(c, r) {
    // Check if point (c,r) is on any segment of the path
    // We treat path as slightly thicker lines
    for (let i = 0; i < pathPoints.length - 1; i++) {
        const p1 = pathPoints[i];
        const p2 = pathPoints[i+1];
        
        // Check if between p1 and p2
        const minX = Math.min(p1.x, p2.x);
        const maxX = Math.max(p1.x, p2.x);
        const minY = Math.min(p1.y, p2.y);
        const maxY = Math.max(p1.y, p2.y);

        if (c >= minX && c <= maxX && r >= minY && r <= maxY) return true;
    }
    return false;
}

init();

</script>
</body>
</html>
